{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Reference","text":"<p>\ufe0f\ud83c\udf9e Subtitles generation tool (Web-UI + CLI + Python package) powered by OpenAI's Whisper and its variants \ud83c\udf9e\ufe0f</p>"},{"location":"#subsai.main","title":"subsai.main","text":"<p>SubsAI: Subtitles AI Subtitles generation tool powered by OpenAI's Whisper and its variants.</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/.</p>"},{"location":"#subsai.main.SubsAI","title":"SubsAI","text":"<p>Subs AI class</p> <p>Example usage: <pre><code>file = './assets/test1.mp4'\nsubs_ai = SubsAI()\nmodel = subs_ai.create_model('openai/whisper', {'model_type': 'base'})\nsubs = subs_ai.transcribe(file, model)\nsubs.save('test1.srt')\n</code></pre></p>"},{"location":"#subsai.main.SubsAI.available_models","title":"available_models  <code>staticmethod</code>","text":"<pre><code>available_models()\n</code></pre> <p>Returns the supported models</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>list of available models</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef available_models() -&gt; list:\n    \"\"\"\n    Returns the supported models\n\n    :return: list of available models\n    \"\"\"\n    return list(AVAILABLE_MODELS.keys())\n</code></pre>"},{"location":"#subsai.main.SubsAI.model_info","title":"model_info  <code>staticmethod</code>","text":"<pre><code>model_info(model)\n</code></pre> <p>Returns general infos about the model (brief description and url)</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>model name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>dict of infos</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef model_info(model: str) -&gt; dict:\n    \"\"\"\n    Returns general infos about the model (brief description and url)\n\n    :param model: model name\n\n    :return: dict of infos\n    \"\"\"\n    return {'description': AVAILABLE_MODELS[model]['description'],\n            'url': AVAILABLE_MODELS[model]['url']}\n</code></pre>"},{"location":"#subsai.main.SubsAI.config_schema","title":"config_schema  <code>staticmethod</code>","text":"<pre><code>config_schema(model)\n</code></pre> <p>Returns the configs associated with a model</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>str</code>)           \u2013            <p>model name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>dict of configs</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef config_schema(model: str) -&gt; dict:\n    \"\"\"\n    Returns the configs associated with a model\n\n    :param model: model name\n\n    :return: dict of configs\n    \"\"\"\n    return AVAILABLE_MODELS[model]['config_schema']\n</code></pre>"},{"location":"#subsai.main.SubsAI.create_model","title":"create_model  <code>staticmethod</code>","text":"<pre><code>create_model(model_name, model_config={})\n</code></pre> <p>Returns a model instance</p> <p>Parameters:</p> <ul> <li> <code>model_name</code>               (<code>str</code>)           \u2013            <p>the name of the model</p> </li> <li> <code>model_config</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>the configuration dict</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractModel</code>           \u2013            <p>the model instance</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef create_model(model_name: str, model_config: dict = {}) -&gt; AbstractModel:\n    \"\"\"\n    Returns a model instance\n\n    :param model_name: the name of the model\n    :param model_config: the configuration dict\n\n    :return: the model instance\n    \"\"\"\n    return AVAILABLE_MODELS[model_name]['class'](model_config)\n</code></pre>"},{"location":"#subsai.main.SubsAI.transcribe","title":"transcribe  <code>staticmethod</code>","text":"<pre><code>transcribe(media_file, model, model_config={})\n</code></pre> <p>Takes the model instance (created by :func:<code>create_model</code>) or the model name. Returns a :class:<code>pysubs2.SSAFile</code> https://pysubs2.readthedocs.io/en/latest/api-reference.html#ssafile-a-subtitle-file`_</p> <p>Parameters:</p> <ul> <li> <code>media_file</code>               (<code>str</code>)           \u2013            <p>path of the media file (video/audio)</p> </li> <li> <code>model</code>               (<code>Union[AbstractModel, str]</code>)           \u2013            <p>model instance or model name</p> </li> <li> <code>model_config</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>model configs' dict</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SSAFile</code>           \u2013            <p>SSAFile: list of subtitles</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef transcribe(media_file: str, model: Union[AbstractModel, str], model_config: dict = {}) -&gt; SSAFile:\n    \"\"\"\n    Takes the model instance (created by :func:`create_model`) or the model name.\n    Returns a :class:`pysubs2.SSAFile` &lt;https://pysubs2.readthedocs.io/en/latest/api-reference.html#ssafile-a-subtitle-file&gt;`_\n\n    :param media_file: path of the media file (video/audio)\n    :param model: model instance or model name\n    :param model_config: model configs' dict\n\n    :return: SSAFile: list of subtitles\n    \"\"\"\n    if type(model) == str:\n        stt_model = SubsAI.create_model(model, model_config)\n    else:\n        stt_model = model\n    media_file = str(pathlib.Path(media_file).resolve())\n    return stt_model.transcribe(media_file)\n</code></pre>"},{"location":"#subsai.main.Tools","title":"Tools","text":"<pre><code>Tools()\n</code></pre> <p>Some tools related to subtitles processing (ex: translation)</p> Source code in <code>src/subsai/main.py</code> <pre><code>def __init__(self):\n    pass\n</code></pre>"},{"location":"#subsai.main.Tools.available_translation_models","title":"available_translation_models  <code>staticmethod</code>","text":"<pre><code>available_translation_models()\n</code></pre> <p>Returns available translation models A simple link to :func:<code>utils.available_translation_models</code> for easy access</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>list of available models</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef available_translation_models() -&gt; list:\n    \"\"\"\n    Returns available translation models\n    A simple link to :func:`utils.available_translation_models` for easy access\n\n    :return: list of available models\n    \"\"\"\n\n    return available_translation_models()\n</code></pre>"},{"location":"#subsai.main.Tools.available_translation_languages","title":"available_translation_languages  <code>staticmethod</code>","text":"<pre><code>available_translation_languages(model)\n</code></pre> <p>Returns the languages supported by the translation model</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>Union[str, TranslationModel]</code>)           \u2013            <p>the name of the model</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>list of available languages</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef available_translation_languages(model: Union[str, TranslationModel]) -&gt; list:\n    \"\"\"\n    Returns the languages supported by the translation model\n\n    :param model: the name of the model\n    :return: list of available languages\n    \"\"\"\n    if type(model) == str:\n        langs = Tools.create_translation_model(model).available_languages()\n    else:\n        langs = model.available_languages()\n    return langs\n</code></pre>"},{"location":"#subsai.main.Tools.create_translation_model","title":"create_translation_model  <code>staticmethod</code>","text":"<pre><code>create_translation_model(\n    model_name=\"m2m100\", model_family=None\n)\n</code></pre> <p>Creates and returns a translation model instance.</p> <p>Parameters:</p> <ul> <li> <code>model_name</code>               (<code>str</code>, default:                   <code>'m2m100'</code> )           \u2013            <p>name of the model. To get available models use :func:<code>available_translation_models</code></p> </li> <li> <code>model_family</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Either \"mbart50\" or \"m2m100\". By default, See <code>dl-translate</code> docs</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TranslationModel</code>           \u2013            <p>A translation model instance</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef create_translation_model(model_name: str = \"m2m100\", model_family: str = None) -&gt; TranslationModel:\n    \"\"\"\n    Creates and returns a translation model instance.\n\n    :param model_name: name of the model. To get available models use :func:`available_translation_models`\n    :param model_family: Either \"mbart50\" or \"m2m100\". By default, See `dl-translate` docs\n    :return: A translation model instance\n    \"\"\"\n    mt = TranslationModel(model_or_path=model_name, model_family=model_family)\n    return mt\n</code></pre>"},{"location":"#subsai.main.Tools.translate","title":"translate  <code>staticmethod</code>","text":"<pre><code>translate(\n    subs,\n    source_language,\n    target_language,\n    model=\"m2m100\",\n    model_family=None,\n    translation_configs={},\n)\n</code></pre> <p>Translates a subtitles <code>SSAFile</code> object, what :func:<code>SubsAI.transcribe</code> is returning</p> <p>Parameters:</p> <ul> <li> <code>subs</code>               (<code>SSAFile</code>)           \u2013            <p><code>SSAFile</code> object</p> </li> <li> <code>source_language</code>               (<code>str</code>)           \u2013            <p>the language of the subtitles</p> </li> <li> <code>target_language</code>               (<code>str</code>)           \u2013            <p>the target language</p> </li> <li> <code>model</code>               (<code>Union[str, TranslationModel]</code>, default:                   <code>'m2m100'</code> )           \u2013            <p>the translation model, either an <code>str</code> or the model instance created by :func:<code>create_translation_model</code></p> </li> <li> <code>model_family</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Either \"mbart50\" or \"m2m100\". By default, See <code>dl-translate</code> docs</p> </li> <li> <code>translation_configs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>dict of translation configs (see :attr:<code>configs.ADVANCED_TOOLS_CONFIGS</code>)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SSAFile</code>           \u2013            <p>returns an <code>SSAFile</code> subtitles translated to the target language</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef translate(subs: SSAFile,\n              source_language: str,\n              target_language: str,\n              model: Union[str, TranslationModel] = \"m2m100\",\n              model_family: str = None,\n              translation_configs: dict = {}) -&gt; SSAFile:\n    \"\"\"\n    Translates a subtitles `SSAFile` object, what :func:`SubsAI.transcribe` is returning\n\n    :param subs: `SSAFile` object\n    :param source_language: the language of the subtitles\n    :param target_language: the target language\n    :param model: the translation model, either an `str` or the model instance created by\n                    :func:`create_translation_model`\n    :param model_family: Either \"mbart50\" or \"m2m100\". By default, See `dl-translate` docs\n    :param translation_configs: dict of translation configs (see :attr:`configs.ADVANCED_TOOLS_CONFIGS`)\n\n    :return: returns an `SSAFile` subtitles translated to the target language\n    \"\"\"\n    if type(model) == str:\n        translation_model = Tools.create_translation_model(model_name=model, model_family=model_family)\n    else:\n        translation_model = model\n\n    translated_subs = SSAFile()\n    for sub in subs:\n        translated_sub = sub.copy()\n        translated_sub.text = translation_model.translate(text=sub.text,\n                                                          source=source_language,\n                                                          target=target_language,\n                                                          batch_size=translation_configs[\n                                                              'batch_size'] if 'batch_size' in translation_configs else 32,\n                                                          verbose=translation_configs[\n                                                              'verbose'] if 'verbose' in translation_configs else False)\n        translated_subs.append(translated_sub)\n    return translated_subs\n</code></pre>"},{"location":"#subsai.main.Tools.auto_sync","title":"auto_sync  <code>staticmethod</code>","text":"<pre><code>auto_sync(subs, media_file, **kwargs)\n</code></pre> <p>Uses (ffsubsync)[https://github.com/smacke/ffsubsync] to auto-sync subtitles to the media file</p> <p>Parameters:</p> <ul> <li> <code>subs</code>               (<code>SSAFile</code>)           \u2013            <p><code>SSAFile</code> file</p> </li> <li> <code>media_file</code>               (<code>str</code>)           \u2013            <p>path of the media_file</p> </li> <li> <code>kwargs</code>           \u2013            <p>configs to pass to ffsubsync (see :attr:<code>configs.ADVANCED_TOOLS_CONFIGS</code>)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SSAFile</code>           \u2013            <p><code>SSAFile</code> auto-synced</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef auto_sync(subs: SSAFile,\n              media_file: str,\n              **kwargs\n              ) -&gt; SSAFile:\n    \"\"\"\n    Uses (ffsubsync)[https://github.com/smacke/ffsubsync] to auto-sync subtitles to the media file\n\n    :param subs: `SSAFile` file\n    :param media_file: path of the media_file\n    :param kwargs: configs to pass to ffsubsync (see :attr:`configs.ADVANCED_TOOLS_CONFIGS`)\n\n    :return: `SSAFile` auto-synced\n    \"\"\"\n    parser = make_parser()\n    srtin_file = tempfile.NamedTemporaryFile(delete=False)\n    srtout_file = tempfile.NamedTemporaryFile(delete=False)\n    try:\n        srtin = srtin_file.name + '.ass'\n        srtout = srtout_file.name + '.srt'\n        subs.save(srtin)\n        cmd = [media_file,\n               '-i', srtin,\n               '-o', srtout]\n        for config_name in kwargs:\n            value = kwargs[config_name]\n            if value is None or value is False:\n                continue\n            elif type(value) == bool and value is True:\n                cmd.append(f'--{config_name}')\n            else:\n                cmd.append(f'--{config_name}')\n                cmd.append(f'{value}')\n        parsed_args = parser.parse_args(cmd)\n        retval = run(parsed_args)[\"retval\"]\n        synced_subs = pysubs2.load(srtout)\n        return synced_subs\n    finally:\n        srtin_file.close()\n        os.unlink(srtin_file.name)\n        srtout_file.close()\n        os.unlink(srtout_file.name)\n</code></pre>"},{"location":"#subsai.main.Tools.merge_subs_with_video","title":"merge_subs_with_video  <code>staticmethod</code>","text":"<pre><code>merge_subs_with_video(\n    subs, media_file, output_filename=None, **kwargs\n)\n</code></pre> <p>Uses ffmpeg to merge subtitles into a video media file. You cna merge multiple subs at the same time providing a dict with (lang,<code>SSAFile</code> object) key,value pairs Example: <pre><code>    file = '../../assets/video/test1.webm'\n    subs_ai = SubsAI()\n    model = subs_ai.create_model('openai/whisper', {'model_type': 'tiny'})\n    en_subs = subs_ai.transcribe(file, model)\n    ar_subs = pysubs2.load('../../assets/video/test0-ar.srt')\n    Tools.merge_subs_with_video2({'English': subs, \"Arabic\": subs2}, file)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>subs</code>               (<code>Dict[str, SSAFile]</code>)           \u2013            <p>dict with (lang,<code>SSAFile</code> object) key,value pairs</p> </li> <li> <code>media_file</code>               (<code>str</code>)           \u2013            <p>path of the video media_file</p> </li> <li> <code>output_filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Output file name (without the extension as it will be inferred from the media file)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Absolute path of the output file</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef merge_subs_with_video(subs: Dict[str, SSAFile],\n              media_file: str,\n              output_filename: str = None,\n              **kwargs\n              ) -&gt; str:\n    \"\"\"\n    Uses ffmpeg to merge subtitles into a video media file.\n    You cna merge multiple subs at the same time providing a dict with (lang,`SSAFile` object) key,value pairs\n    Example:\n    ```python\n        file = '../../assets/video/test1.webm'\n        subs_ai = SubsAI()\n        model = subs_ai.create_model('openai/whisper', {'model_type': 'tiny'})\n        en_subs = subs_ai.transcribe(file, model)\n        ar_subs = pysubs2.load('../../assets/video/test0-ar.srt')\n        Tools.merge_subs_with_video2({'English': subs, \"Arabic\": subs2}, file)\n    ```\n\n    :param subs: dict with (lang,`SSAFile` object) key,value pairs\n    :param media_file: path of the video media_file\n    :param output_filename: Output file name (without the extension as it will be inferred from the media file)\n\n    :return: Absolute path of the output file\n    \"\"\"\n    metadata = ffmpeg.probe(media_file, select_streams=\"v\")['streams'][0]\n    assert metadata['codec_type'] == 'video', f'File {media_file} is not a video'\n\n\n    srtin_files = {key: tempfile.NamedTemporaryFile(delete=False) for key in subs}\n    try:\n        in_file = pathlib.Path(media_file)\n        if output_filename is not None:\n            out_file = in_file.parent / f\"{output_filename}{in_file.suffix}\"\n        else:\n            out_file = in_file.parent / f\"{in_file.stem}-subs-merged{in_file.suffix}\"\n\n        video = str(in_file.resolve())\n        metadata_subs = {'scodec': 'mov_text'} if metadata['codec_name'] == 'h264' else {}\n        ffmpeg_subs_inputs = []\n        for i,lang in enumerate(srtin_files):\n            srtin = srtin_files[lang].name + '.srt'\n            subs[lang].save(srtin)\n            ffmpeg_subs_inputs.append(ffmpeg.input(srtin)['s'])\n            metadata_subs[f'metadata:s:s:{i}'] = \"title=\" + lang\n\n        output_file = str(out_file.resolve())\n        input_ffmpeg = ffmpeg.input(video)\n        input_video = input_ffmpeg['v']\n        input_audio = input_ffmpeg['a']\n        output_ffmpeg = ffmpeg.output(\n            input_video, input_audio, *ffmpeg_subs_inputs, output_file,\n            vcodec='copy', acodec='copy',\n            # scodec='mov_text',\n            **metadata_subs\n        )\n        output_ffmpeg = ffmpeg.overwrite_output(output_ffmpeg)\n        ffmpeg.run(output_ffmpeg)\n    finally:\n        for srtin_file in srtin_files.values():\n            srtin_file.close()\n            os.unlink(srtin_file.name)\n    return str(out_file.resolve())\n</code></pre>"},{"location":"#subsai.models","title":"subsai.models","text":""},{"location":"#subsai.models.abstract_model","title":"abstract_model","text":"<p>API that the transcription models should follow</p>"},{"location":"#subsai.models.abstract_model.AbstractModel","title":"AbstractModel","text":"<pre><code>AbstractModel(model_name=None, model_config={})\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract Model class</p> Source code in <code>src/subsai/models/abstract_model.py</code> <pre><code>def __init__(self, model_name=None, model_config={}):\n    self.model_name = model_name\n    self.model_config = model_config\n</code></pre>"},{"location":"#subsai.models.abstract_model.AbstractModel.model_name","title":"model_name  <code>instance-attribute</code>","text":"<pre><code>model_name = model_name\n</code></pre>"},{"location":"#subsai.models.abstract_model.AbstractModel.model_config","title":"model_config  <code>instance-attribute</code>","text":"<pre><code>model_config = model_config\n</code></pre>"},{"location":"#subsai.models.abstract_model.AbstractModel.transcribe","title":"transcribe  <code>abstractmethod</code>","text":"<pre><code>transcribe(media_file)\n</code></pre> <p>Transcribe the <code>media_file</code> to subtitles.</p> <p>example use case from pysubs2.whisper:</p> <p>.. code-block:: python     :linenos:</p> <p>subs = SSAFile() for segment in segments:     event = SSAEvent(start=make_time(s=segment[\"start\"]), end=make_time(s=segment[\"end\"]))     event.plaintext = segment[\"text\"].strip()     subs.append(event)</p> <p>Parameters:</p> <ul> <li> <code>media_file</code>           \u2013            <p>Path of the media file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SSAFile</code>           \u2013            <p>Collection of SSAEvent(s) (see :mod:<code>pysubs2.ssaevent</code>)</p> </li> </ul> Source code in <code>src/subsai/models/abstract_model.py</code> <pre><code>@abstractmethod\ndef transcribe(self, media_file) -&gt; SSAFile:\n    \"\"\"\n    Transcribe the `media_file` to subtitles.\n\n    example use case from pysubs2.whisper:\n\n    .. code-block:: python\n        :linenos:\n\n    subs = SSAFile()\n    for segment in segments:\n        event = SSAEvent(start=make_time(s=segment[\"start\"]), end=make_time(s=segment[\"end\"]))\n        event.plaintext = segment[\"text\"].strip()\n        subs.append(event)\n\n    :param media_file: Path of the media file\n    :return: Collection of SSAEvent(s) (see :mod:`pysubs2.ssaevent`)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model","title":"faster_whisper_model","text":"<p>Faster Whisper Model</p> <p>See guillaumekln/faster-whisper</p>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel","title":"FasterWhisperModel","text":"<pre><code>FasterWhisperModel(model_config)\n</code></pre> <p>               Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/faster_whisper_model.py</code> <pre><code>def __init__(self, model_config):\n    super(FasterWhisperModel, self).__init__(model_config=model_config,\n                                       model_name=self.model_name)\n    # config\n    self._model_size_or_path = _load_config('model_size_or_path', model_config, self.config_schema)\n    self._device = _load_config('device', model_config, self.config_schema)\n    self._device_index = _load_config('device_index', model_config, self.config_schema)\n    self._compute_type = _load_config('compute_type', model_config, self.config_schema)\n    self._cpu_threads = _load_config('cpu_threads', model_config, self.config_schema)\n    self._num_workers = _load_config('num_workers', model_config, self.config_schema)\n\n    self.transcribe_configs = \\\n        {config: _load_config(config, model_config, self.config_schema)\n         for config in self.config_schema if not hasattr(self, f\"_{config}\")}\n\n    self.model = WhisperModel(model_size_or_path=self._model_size_or_path,\n                              device=self._device,\n                              device_index=self._device_index,\n                              compute_type=self._compute_type,\n                              cpu_threads=self._cpu_threads,\n                              num_workers=self._num_workers)\n\n\n    # to show the progress\n    import logging\n\n    logging.basicConfig()\n    logging.getLogger(\"faster_whisper\").setLevel(logging.DEBUG)\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'guillaumekln/faster-whisper'\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_size_or_path\": {\n        \"type\": list,\n        \"description\": 'Size of the model to use (e.g. \"large-v2\", \"small\", \"tiny.en\", etc.)or a path to a converted model directory. When a size is configured, the convertedmodel is downloaded from the Hugging Face Hub.',\n        \"options\": available_models(),\n        \"default\": \"base\",\n    },\n    \"device\": {\n        \"type\": list,\n        \"description\": 'Device to use for computation (\"cpu\", \"cuda\", \"auto\")',\n        \"options\": [\"auto\", \"cpu\", \"cuda\"],\n        \"default\": \"auto\",\n    },\n    \"device_index\": {\n        \"type\": int,\n        \"description\": \"Device ID to use.The model can also be loaded on multiple GPUs by passing a list of IDs(e.g. [0, 1, 2, 3]). In that case, multiple transcriptions can run in parallelwhen transcribe() is called from multiple Python threads (see also num_workers).\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"compute_type\": {\n        \"type\": str,\n        \"description\": \"Type to use for computation.See https://opennmt.net/CTranslate2/quantization.html.\",\n        \"options\": None,\n        \"default\": \"default\",\n    },\n    \"cpu_threads\": {\n        \"type\": int,\n        \"description\": \"Number of threads to use when running on CPU (4 by default).A non zero value overrides the OMP_NUM_THREADS environment variable.\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"num_workers\": {\n        \"type\": int,\n        \"description\": \"When transcribe() is called from multiple Python threads,having multiple workers enables true parallelism when running the model(concurrent calls to self.model.generate() will run in parallel).This can improve the global throughput at the cost of increased memory usage.\",\n        \"options\": None,\n        \"default\": 1,\n    },\n    \"temperature\": {\n        \"type\": Tuple,\n        \"description\": \"Temperature for sampling. It can be a tuple of temperatures, which will be successively used upon failures according to either `compression_ratio_threshold` or `logprob_threshold`.\",\n        \"options\": None,\n        \"default\": [0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n    },\n    \"compression_ratio_threshold\": {\n        \"type\": float,\n        \"description\": \"If the gzip compression ratio is above this value, treat as failed\",\n        \"options\": None,\n        \"default\": 2.4,\n    },\n    \"log_prob_threshold\": {\n        \"type\": float,\n        \"description\": \"If the average log probability over sampled tokens is below this value, treat as failed\",\n        \"options\": None,\n        \"default\": -1.0,\n    },\n    \"no_speech_threshold\": {\n        \"type\": float,\n        \"description\": \"If the no_speech probability is higher than this value AND the average log probability over sampled tokens is below `logprob_threshold`, consider the segment as silent\",\n        \"options\": None,\n        \"default\": 0.6,\n    },\n    \"condition_on_previous_text\": {\n        \"type\": bool,\n        \"description\": \"if True, the previous output of the model is provided as a prompt for the next window; disabling may make the text inconsistent across windows, but the model becomes less prone to getting stuck in a failure loop, such as repetition looping or timestamps going out of sync.\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"task\": {\n        \"type\": list,\n        \"description\": \"whether to perform X-&gt;X 'transcribe' or X-&gt;English 'translate'\",\n        \"options\": [\"transcribe\", \"translate\"],\n        \"default\": \"transcribe\",\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": \"language that the audio is in; uses detected language if None\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"best_of\": {\n        \"type\": int,\n        \"description\": \"number of independent samples to collect, when t &gt; 0\",\n        \"options\": None,\n        \"default\": 5,\n    },\n    \"beam_size\": {\n        \"type\": int,\n        \"description\": \"number of beams in beam search, when t == 0\",\n        \"options\": None,\n        \"default\": 5,\n    },\n    \"patience\": {\n        \"type\": float,\n        \"description\": \"patience in beam search (https://arxiv.org/abs/2204.05424)\",\n        \"options\": None,\n        \"default\": 1.0,\n    },\n    \"length_penalty\": {\n        \"type\": float,\n        \"description\": \"'alpha' in Google NMT, None defaults to length norm\",\n        \"options\": None,\n        \"default\": 1.0,\n    },\n    \"prefix\": {\n        \"type\": str,\n        \"description\": \"text or tokens to prefix the current context\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"suppress_blank\": {\n        \"type\": bool,\n        \"description\": \"this will suppress blank outputs\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"suppress_tokens\": {\n        \"type\": Tuple,\n        \"description\": 'list of tokens ids (or comma-separated token ids) to suppress \"-1\" will suppress a set of symbols as defined in `tokenizer.non_speech_tokens()`',\n        \"options\": None,\n        \"default\": [-1],\n    },\n    \"without_timestamps\": {\n        \"type\": bool,\n        \"description\": \"use &lt;|notimestamps|&gt; to sample text tokens only\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"max_initial_timestamp\": {\n        \"type\": float,\n        \"description\": \"the initial timestamp cannot be later than this\",\n        \"options\": None,\n        \"default\": 1.0,\n    },\n    \"initial_prompt\": {\n        \"type\": str,\n        \"description\": \"Optional text to provide as a prompt for the first window.\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"word_timestamps\": {\n        \"type\": bool,\n        \"description\": \"Extract word-level timestamps using the cross-attention patternand dynamic time warping, and include the timestamps for each word in each segment.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"prepend_punctuations\": {\n        \"type\": str,\n        \"description\": \"If word_timestamps is True, merge these punctuation symbolswith the next word\",\n        \"options\": None,\n        \"default\": \"\\\"'\u201c\u00bf([{-\",\n    },\n    \"append_punctuations\": {\n        \"type\": str,\n        \"description\": \"If word_timestamps is True, merge these punctuation symbolswith the previous word\",\n        \"options\": None,\n        \"default\": \"\\\"'.\u3002,\uff0c!\uff01?\uff1f:\uff1a\u201d)]}\u3001\",\n    },\n    \"vad_filter\": {\n        \"type\": bool,\n        \"description\": \"If True, use the integrated Silero VAD model to filter out parts of the audio without speech.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"vad_parameters\": {\n        \"type\": dict,\n        \"description\": \"Parameters for splitting long audios into speech chunks using silero VAD.\",\n        \"options\": None,\n        \"default\": {\n            \"threshold\": 0.5,\n            \"min_speech_duration_ms\": 250,\n            \"max_speech_duration_s\": float(\"inf\"),\n            \"min_silence_duration_ms\": 2000,\n            \"window_size_samples\": 1024,\n            \"speech_pad_ms\": 400,\n        },\n    },\n}\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel.transcribe_configs","title":"transcribe_configs  <code>instance-attribute</code>","text":"<pre><code>transcribe_configs = {\n    config: _load_config(\n        config, model_config, config_schema\n    )\n    for config in config_schema\n    if not hasattr(self, f\"_{config}\")\n}\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = WhisperModel(\n    model_size_or_path=_model_size_or_path,\n    device=_device,\n    device_index=_device_index,\n    compute_type=_compute_type,\n    cpu_threads=_cpu_threads,\n    num_workers=_num_workers,\n)\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/faster_whisper_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; str:\n    segments, info = self.model.transcribe(media_file, **self.transcribe_configs)\n    subs = SSAFile()\n    total_duration = round(info.duration, 2)  # Same precision as the Whisper timestamps.\n    timestamps = 0.0  # to get the current segments\n    with tqdm(total=total_duration, unit=\" audio seconds\") as pbar:\n        if self.transcribe_configs['word_timestamps']:  # word level timestamps\n            for segment in segments:\n                pbar.update(segment.end - timestamps)\n                timestamps = segment.end\n                if timestamps &lt; info.duration:\n                    pbar.update(info.duration - timestamps)\n                for word in segment.words:\n                    event = SSAEvent(start=pysubs2.make_time(s=word.start), end=pysubs2.make_time(s=word.end))\n                    event.plaintext = word.word.strip()\n                    subs.append(event)\n        else:\n            for segment in segments:\n                pbar.update(segment.end - timestamps)\n                timestamps = segment.end\n                if timestamps &lt; info.duration:\n                    pbar.update(info.duration - timestamps)\n                event = SSAEvent(start=pysubs2.make_time(s=segment.start), end=pysubs2.make_time(s=segment.end))\n                event.plaintext = segment.text.strip()\n                subs.append(event)\n\n    return subs\n</code></pre>"},{"location":"#subsai.models.hugging_face_model","title":"hugging_face_model","text":"<p>Hugging Face Model</p> <p>See automatic-speech-recognition</p>"},{"location":"#subsai.models.hugging_face_model.devices","title":"devices  <code>module-attribute</code>","text":"<pre><code>devices = get_available_devices()\n</code></pre>"},{"location":"#subsai.models.hugging_face_model.HuggingFaceModel","title":"HuggingFaceModel","text":"<pre><code>HuggingFaceModel(model_config)\n</code></pre> <p>               Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/hugging_face_model.py</code> <pre><code>def __init__(self, model_config):\n    super(HuggingFaceModel, self).__init__(model_config=model_config,\n                                           model_name=self.model_name)\n    # config\n    self._model_id = _load_config('model_id', model_config, self.config_schema)\n    self._device = _load_config('device', model_config, self.config_schema)\n    self.segment_type = _load_config('segment_type', model_config, self.config_schema)\n    self._chunk_length_s = _load_config('chunk_length_s', model_config, self.config_schema)\n\n\n    self.model = pipeline(\n        \"automatic-speech-recognition\",\n        model=self._model_id,\n        device=self._device,\n    )\n</code></pre>"},{"location":"#subsai.models.hugging_face_model.HuggingFaceModel.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'HuggingFaceModel'\n</code></pre>"},{"location":"#subsai.models.hugging_face_model.HuggingFaceModel.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_id\": {\n        \"type\": str,\n        \"description\": \"The model id from the Hugging Face Hub.\",\n        \"options\": None,\n        \"default\": \"openai/whisper-tiny\",\n    },\n    \"device\": {\n        \"type\": list,\n        \"description\": \"Pytorch device\",\n        \"options\": devices,\n        \"default\": devices[0],\n    },\n    \"segment_type\": {\n        \"type\": list,\n        \"description\": \"Sentence-level or word-level timestamps\",\n        \"options\": [\"sentence\", \"word\"],\n        \"default\": \"sentence\",\n    },\n    \"chunk_length_s\": {\n        \"type\": float,\n        \"description\": \"(`float`, *optional*, defaults to 0):The input length for in each chunk. If `chunk_length_s = 0` then chunking is disabled (default).\",\n        \"options\": None,\n        \"default\": 30,\n    },\n}\n</code></pre>"},{"location":"#subsai.models.hugging_face_model.HuggingFaceModel.segment_type","title":"segment_type  <code>instance-attribute</code>","text":"<pre><code>segment_type = _load_config(\n    \"segment_type\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.hugging_face_model.HuggingFaceModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = pipeline(\n    \"automatic-speech-recognition\",\n    model=_model_id,\n    device=_device,\n)\n</code></pre>"},{"location":"#subsai.models.hugging_face_model.HuggingFaceModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/hugging_face_model.py</code> <pre><code>def transcribe(self, media_file):\n    results = self.model(\n        media_file,\n        chunk_length_s=self._chunk_length_s,\n        return_timestamps=True if self.segment_type == 'sentence' else 'word',\n    )\n    subs = SSAFile()\n    for chunk in results['chunks']:\n        event = SSAEvent(start=pysubs2.make_time(s=chunk['timestamp'][0]),\n                         end=pysubs2.make_time(s=chunk['timestamp'][1]))\n        event.plaintext = chunk['text']\n        subs.append(event)\n    return subs\n</code></pre>"},{"location":"#subsai.models.stable_ts_model","title":"stable_ts_model","text":"<p>Stable-ts Model</p> <p>See jianfch/stable-ts</p>"},{"location":"#subsai.models.stable_ts_model.StableTsModel","title":"StableTsModel","text":"<pre><code>StableTsModel(model_config)\n</code></pre> <p>               Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/stable_ts_model.py</code> <pre><code>def __init__(self, model_config):\n    super(StableTsModel, self).__init__(model_config=model_config,\n                                        model_name=self.model_name)\n    # config\n    self._model_type = _load_config('model_type', model_config, self.config_schema)\n    self._device = _load_config('device', model_config, self.config_schema)\n    self._in_memory = _load_config('in_memory', model_config, self.config_schema)\n    self._cpu_preload = _load_config('cpu_preload', model_config, self.config_schema)\n    self._dq = _load_config('dq', model_config, self.config_schema)\n\n    self._verbose = _load_config('verbose', model_config, self.config_schema)\n    self._temperature = _load_config('temperature', model_config, self.config_schema)\n    self._compression_ratio_threshold = _load_config('compression_ratio_threshold', model_config, self.config_schema)\n    self._logprob_threshold = _load_config('logprob_threshold', model_config, self.config_schema)\n    self._no_speech_threshold = _load_config('no_speech_threshold', model_config, self.config_schema)\n    self._condition_on_previous_text = _load_config('condition_on_previous_text', model_config, self.config_schema)\n    self._initial_prompt = _load_config('initial_prompt', model_config, self.config_schema)\n    self._word_timestamps = _load_config('word_timestamps', model_config, self.config_schema)\n    self._regroup = _load_config('regroup', model_config, self.config_schema)\n    self._ts_num = _load_config('ts_num', model_config, self.config_schema)\n    self._ts_noise = _load_config('ts_noise', model_config, self.config_schema)\n    self._suppress_silence = _load_config('suppress_silence', model_config, self.config_schema)\n    self._suppress_word_ts = _load_config('suppress_word_ts', model_config, self.config_schema)\n    self._q_levels = _load_config('q_levels', model_config, self.config_schema)\n    self._k_size = _load_config('k_size', model_config, self.config_schema)\n    self._time_scale = _load_config('time_scale', model_config, self.config_schema)\n    self._demucs = _load_config('demucs', model_config, self.config_schema)\n    self._demucs_output = _load_config('demucs_output', model_config, self.config_schema)\n    self._demucs_options = _load_config('demucs_options', model_config, self.config_schema)\n    self._vad = _load_config('vad', model_config, self.config_schema)\n    self._vad_threshold = _load_config('vad_threshold', model_config, self.config_schema)\n    self._vad_onnx = _load_config('vad_onnx', model_config, self.config_schema)\n    self._min_word_dur = _load_config('min_word_dur', model_config, self.config_schema)\n    self._only_voice_freq = _load_config('only_voice_freq', model_config, self.config_schema)\n    self._prepend_punctuations = _load_config('prepend_punctuations', model_config, self.config_schema)\n    self._append_punctuations = _load_config('append_punctuations', model_config, self.config_schema)\n    self._mel_first = _load_config('mel_first', model_config, self.config_schema)\n    self._suppress_ts_tokens = _load_config('suppress_ts_tokens', model_config, self.config_schema)\n    self._gap_padding = _load_config('gap_padding', model_config, self.config_schema)\n    self._only_ffmpeg = _load_config('only_ffmpeg', model_config, self.config_schema)\n    self._max_instant_words = _load_config('max_instant_words', model_config, self.config_schema)\n    self._avg_prob_threshold = _load_config('avg_prob_threshold', model_config, self.config_schema)\n    self._ignore_compatibility = _load_config('ignore_compatibility', model_config, self.config_schema)\n\n    self.transcribe_configs = \\\n        {config: _load_config(config, model_config, self.config_schema)\n         for config in self.config_schema if not hasattr(self, f\"_{config}\")}\n\n    self.model = load_model(name=self._model_type,\n                            device=self._device,\n                            in_memory=self._in_memory,\n                            cpu_preload=self._cpu_preload,\n                            dq=self._dq)\n</code></pre>"},{"location":"#subsai.models.stable_ts_model.StableTsModel.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'jianfch/stable-ts'\n</code></pre>"},{"location":"#subsai.models.stable_ts_model.StableTsModel.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_type\": {\n        \"type\": list,\n        \"description\": \"One of the official model names listed by `whisper.available_models()`, or path to a model checkpoint containing the model dimensions and the model state_dict.\",\n        \"options\": available_models(),\n        \"default\": \"base\",\n    },\n    \"device\": {\n        \"type\": list,\n        \"description\": \"The PyTorch device to put the model into\",\n        \"options\": [None, *get_available_devices()],\n        \"default\": None,\n    },\n    \"in_memory\": {\n        \"type\": bool,\n        \"description\": \"bool, default False, Whether to preload the model weights into host memory.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"cpu_preload\": {\n        \"type\": bool,\n        \"description\": \"Load model into CPU memory first then move model to specified device to reduce GPU memory usage when loading model\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"dq\": {\n        \"type\": bool,\n        \"description\": \"Whether to apply Dynamic Quantization to model to reduced memory usage and increase inference speed but at the cost of a slight decrease in accuracy. Only for CPU.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"verbose\": {\n        \"type\": bool,\n        \"description\": \"Whether to display the text being decoded to the console. If True, displays all the details,If False, displays minimal details. If None, does not display anything\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"temperature\": {\n        \"type\": Tuple,\n        \"description\": \"Temperature for sampling. It can be a tuple of temperatures, which will be successively used upon failures according to either `compression_ratio_threshold` or `logprob_threshold`.\",\n        \"options\": None,\n        \"default\": (0.0, 0.2, 0.4, 0.6, 0.8, 1.0),\n    },\n    \"compression_ratio_threshold\": {\n        \"type\": float,\n        \"description\": \"If the gzip compression ratio is above this value, treat as failed\",\n        \"options\": None,\n        \"default\": 2.4,\n    },\n    \"logprob_threshold\": {\n        \"type\": float,\n        \"description\": \"If the average log probability over sampled tokens is below this value, treat as failed\",\n        \"options\": None,\n        \"default\": -1.0,\n    },\n    \"no_speech_threshold\": {\n        \"type\": float,\n        \"description\": \"If the no_speech probability is higher than this value AND the average log probability over sampled tokens is below `logprob_threshold`, consider the segment as silent\",\n        \"options\": None,\n        \"default\": 0.6,\n    },\n    \"condition_on_previous_text\": {\n        \"type\": bool,\n        \"description\": \"if True, the previous output of the model is provided as a prompt for the next window; disabling may make the text inconsistent across windows, but the model becomes less prone to getting stuck in a failure loop, such as repetition looping or timestamps going out of sync.\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"initial_prompt\": {\n        \"type\": str,\n        \"description\": \"Optional text to provide as a prompt for the first window.\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"word_timestamps\": {\n        \"type\": bool,\n        \"description\": \"Extract word-level timestamps using the cross-attention patternand dynamic time warping, and include the timestamps for each word in each segment.\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"regroup\": {\n        \"type\": bool,\n        \"description\": \"default True, meaning the default regroup algorithmString for customizing the regrouping algorithm. False disables regrouping.Ignored if ``word_timestamps = False``.\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"ts_num\": {\n        \"type\": int,\n        \"description\": \"meaning disable this optionNumber of extra timestamp inferences to perform then use average of these extra timestamps.An experimental option that might hurt performance.\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"ts_noise\": {\n        \"type\": float,\n        \"description\": \"Percentage of noise to add to audio_features to perform inferences for ``ts_num``.\",\n        \"options\": None,\n        \"default\": 0.1,\n    },\n    \"suppress_silence\": {\n        \"type\": bool,\n        \"description\": \"Whether to enable timestamps adjustments based on the detected silence.\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"suppress_word_ts\": {\n        \"type\": bool,\n        \"description\": \"Whether to adjust word timestamps based on the detected silence. Only enabled if ``suppress_silence = True``.\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"q_levels\": {\n        \"type\": int,\n        \"description\": \"Quantization levels for generating timestamp suppression mask; ignored if ``vad = true``.Acts as a threshold to marking sound as silent.Fewer levels will increase the threshold of volume at which to mark a sound as silent.\",\n        \"options\": None,\n        \"default\": 20,\n    },\n    \"k_size\": {\n        \"type\": int,\n        \"description\": \"Kernel size for avg-pooling waveform to generate timestamp suppression mask; ignored if ``vad = true``.Recommend 5 or 3; higher sizes will reduce detection of silence.\",\n        \"options\": None,\n        \"default\": 5,\n    },\n    \"time_scale\": {\n        \"type\": float,\n        \"description\": \"Factor for scaling audio duration for inference.Greater than 1.0 'slows down' the audio, and less than 1.0 'speeds up' the audio. None is same as 1.0.A factor of 1.5 will stretch 10s audio to 15s for inference. This increases the effective resolutionof the model but can increase word error rate.\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"demucs\": {\n        \"type\": bool,\n        \"description\": \"Whether to preprocess ``audio`` with Demucs to isolate vocals / remove noise. Set ``demucs`` to an instance ofa Demucs model to avoid reloading the model for each run.Demucs must be installed to use. Official repo. https://github.com/facebookresearch/demucs.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"demucs_output\": {\n        \"type\": str,\n        \"description\": \"Path to save the vocals isolated by Demucs as WAV file. Ignored if ``demucs = False``.Demucs must be installed to use. Official repo. https://github.com/facebookresearch/demucs.\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"demucs_options\": {\n        \"type\": dict,\n        \"description\": \"Options to use for :func:`stable_whisper.audio.demucs_audio`.\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"vad\": {\n        \"type\": bool,\n        \"description\": \"Whether to use Silero VAD to generate timestamp suppression mask.Silero VAD requires PyTorch 1.12.0+. Official repo, https://github.com/snakers4/silero-vad.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"vad_threshold\": {\n        \"type\": float,\n        \"description\": \"Threshold for detecting speech with Silero VAD. Low threshold reduces false positives for silence detection.\",\n        \"options\": None,\n        \"default\": 0.35,\n    },\n    \"vad_onnx\": {\n        \"type\": bool,\n        \"description\": \"Whether to use ONNX for Silero VAD.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"min_word_dur\": {\n        \"type\": float,\n        \"description\": \"Shortest duration each word is allowed to reach for silence suppression.\",\n        \"options\": None,\n        \"default\": 0.1,\n    },\n    \"only_voice_freq\": {\n        \"type\": bool,\n        \"description\": \"Whether to only use sound between 200 - 5000 Hz, where majority of human speech are.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"prepend_punctuations\": {\n        \"type\": str,\n        \"description\": \"If word_timestamps is True, merge these punctuation symbolswith the next word\",\n        \"options\": None,\n        \"default\": \"\\\"'\u201c\u00bf([{-\",\n    },\n    \"append_punctuations\": {\n        \"type\": str,\n        \"description\": \"If word_timestamps is True, merge these punctuation symbolswith the previous word\",\n        \"options\": None,\n        \"default\": \"\\\"'.\u3002,\uff0c!\uff01?\uff1f:\uff1a\u201d)]}\u3001\",\n    },\n    \"mel_first\": {\n        \"type\": bool,\n        \"description\": \"Process entire audio track into log-Mel spectrogram first instead in chunks.Used if odd behavior seen in stable-ts but not in whisper, but use significantly more memory for long audio.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"suppress_ts_tokens\": {\n        \"type\": bool,\n        \"description\": \" Whether to suppress timestamp tokens during inference for timestamps are detected at silent.Reduces hallucinations in some cases, but also prone to ignore disfluencies and repetitions.This option is ignored if ``suppress_silence = False``.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"gap_padding\": {\n        \"type\": str,\n        \"description\": \"Padding prepend to each segments for word timing alignment.Used to reduce the probability of model predicting timestamps earlier than the first utterance.\",\n        \"options\": None,\n        \"default\": \"...\",\n    },\n    \"only_ffmpeg\": {\n        \"type\": bool,\n        \"description\": \"Whether to use only FFmpeg (instead of not yt-dlp) for URls\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"max_instant_words\": {\n        \"type\": float,\n        \"description\": \"If percentage of instantaneous words in a segment exceed this amount, the segment is removed.\",\n        \"options\": None,\n        \"default\": 0.5,\n    },\n    \"avg_prob_threshold\": {\n        \"type\": float,\n        \"description\": \"Transcribe the gap after the previous word and if the average word proababiliy of a segment falls below thisvalue, discard the segment. If ``None``, skip transcribing the gap to reduce chance of timestamps startingbefore the next utterance.\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"ignore_compatibility\": {\n        \"type\": bool,\n        \"description\": \"Whether to ignore warnings for compatibility issues with the detected Whisper version.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"task\": {\n        \"type\": list,\n        \"description\": \"whether to perform X-&gt;X 'transcribe' or X-&gt;English 'translate'\",\n        \"options\": [\"transcribe\", \"translate\"],\n        \"default\": \"transcribe\",\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": \"language that the audio is in; uses detected language if None\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"sample_len\": {\n        \"type\": int,\n        \"description\": \"maximum number of tokens to sample\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"best_of\": {\n        \"type\": int,\n        \"description\": \"number of independent samples to collect, when t &gt; 0\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"beam_size\": {\n        \"type\": int,\n        \"description\": \"number of beams in beam search, when t == 0\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"patience\": {\n        \"type\": float,\n        \"description\": \"patience in beam search (https://arxiv.org/abs/2204.05424)\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"length_penalty\": {\n        \"type\": float,\n        \"description\": \"'alpha' in Google NMT, None defaults to length norm\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"prompt\": {\n        \"type\": str,\n        \"description\": \"text or tokens for the previous context\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"prefix\": {\n        \"type\": str,\n        \"description\": \"text or tokens to prefix the current context\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"suppress_blank\": {\n        \"type\": bool,\n        \"description\": \"this will suppress blank outputs\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"suppress_tokens\": {\n        \"type\": str,\n        \"description\": 'list of tokens ids (or comma-separated token ids) to suppress \"-1\" will suppress a set of symbols as defined in `tokenizer.non_speech_tokens()`',\n        \"options\": None,\n        \"default\": \"-1\",\n    },\n    \"without_timestamps\": {\n        \"type\": bool,\n        \"description\": \"use &lt;|notimestamps|&gt; to sample text tokens only\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"max_initial_timestamp\": {\n        \"type\": float,\n        \"description\": \"the initial timestamp cannot be later than this\",\n        \"options\": None,\n        \"default\": 1.0,\n    },\n    \"fp16\": {\n        \"type\": bool,\n        \"description\": \"use fp16 for most of the calculation\",\n        \"options\": None,\n        \"default\": True,\n    },\n}\n</code></pre>"},{"location":"#subsai.models.stable_ts_model.StableTsModel.transcribe_configs","title":"transcribe_configs  <code>instance-attribute</code>","text":"<pre><code>transcribe_configs = {\n    config: _load_config(\n        config, model_config, config_schema\n    )\n    for config in config_schema\n    if not hasattr(self, f\"_{config}\")\n}\n</code></pre>"},{"location":"#subsai.models.stable_ts_model.StableTsModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = load_model(\n    name=_model_type,\n    device=_device,\n    in_memory=_in_memory,\n    cpu_preload=_cpu_preload,\n    dq=_dq,\n)\n</code></pre>"},{"location":"#subsai.models.stable_ts_model.StableTsModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/stable_ts_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; SSAFile:\n    result = transcribe_stable(self.model,\n                               audio=media_file,\n                               verbose=self._verbose,\n                               temperature=self._temperature,\n                               compression_ratio_threshold=self._compression_ratio_threshold,\n                               logprob_threshold=self._logprob_threshold,\n                               no_speech_threshold=self._no_speech_threshold,\n                               condition_on_previous_text=self._condition_on_previous_text,\n                               initial_prompt=self._initial_prompt,\n                               word_timestamps=self._word_timestamps,\n                               regroup=self._regroup,\n                               ts_num=self._ts_num,\n                               ts_noise=self._ts_noise,\n                               suppress_silence=self._suppress_silence,\n                               suppress_word_ts=self._suppress_word_ts,\n                               q_levels=self._q_levels,\n                               k_size=self._k_size,\n                               time_scale=self._time_scale,\n                               demucs=self._demucs,\n                               demucs_output=self._demucs_output,\n                               demucs_options=self._demucs_options,\n                               vad=self._vad,\n                               vad_threshold=self._vad_threshold,\n                               vad_onnx=self._vad_onnx,\n                               min_word_dur=self._min_word_dur,\n                               only_voice_freq=self._only_voice_freq,\n                               prepend_punctuations=self._prepend_punctuations,\n                               append_punctuations=self._append_punctuations,\n                               mel_first=self._mel_first,\n                               suppress_ts_tokens=self._suppress_ts_tokens,\n                               gap_padding=self._gap_padding,\n                               only_ffmpeg=self._only_ffmpeg,\n                               max_instant_words=self._max_instant_words,\n                               avg_prob_threshold=self._avg_prob_threshold,\n                               ignore_compatibility=self._ignore_compatibility,\n                               **self.transcribe_configs,\n                               )\n\n    subs = SSAFile()\n\n    if self._word_timestamps:  # word level timestamps\n        for segment in result.segments:\n            for word in segment.words:\n                try:\n                    event = SSAEvent(start=pysubs2.make_time(s=word.start), end=pysubs2.make_time(s=word.end))\n                    event.plaintext = word.word.strip()\n                    subs.append(event)\n                except Exception as e:\n                    logging.warning(f\"Something wrong with {word}\")\n                    logging.warning(e)\n\n    else:\n        for segment in result.segments:\n            event = SSAEvent(start=pysubs2.make_time(s=segment.start), end=pysubs2.make_time(s=segment.end))\n            event.plaintext = segment.text.strip()\n            subs.append(event)\n\n\n    return subs\n</code></pre>"},{"location":"#subsai.models.whisperX_model","title":"whisperX_model","text":"<p>WhisperX Model</p> <p>See m-bain/whisperX</p>"},{"location":"#subsai.models.whisperX_model.WhisperXModel","title":"WhisperXModel","text":"<pre><code>WhisperXModel(model_config)\n</code></pre> <p>               Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/whisperX_model.py</code> <pre><code>def __init__(self, model_config):\n    super(WhisperXModel, self).__init__(model_config=model_config,\n                                        model_name=self.model_name)\n    # config\n    self.model_type = _load_config('model_type', model_config, self.config_schema)\n    self.device = _load_config('device', model_config, self.config_schema)\n    self.compute_type = _load_config('compute_type', model_config, self.config_schema)\n    self.download_root = _load_config('download_root', model_config, self.config_schema)\n    self.language = _load_config('language', model_config, self.config_schema)\n    self.segment_type = _load_config('segment_type', model_config, self.config_schema)\n    # transcribe config\n    self.batch_size = _load_config('batch_size', model_config, self.config_schema)\n    self.return_char_alignments = _load_config('return_char_alignments', model_config, self.config_schema)\n    self.speaker_labels = _load_config('speaker_labels', model_config, self.config_schema)\n    self.HF_TOKEN = _load_config('HF_TOKEN', model_config, self.config_schema)\n    self.min_speakers = _load_config('min_speakers', model_config, self.config_schema)\n    self.max_speakers = _load_config('max_speakers', model_config, self.config_schema)\n\n    self.model = whisperx.load_model(self.model_type,\n                                     device=self.device,\n                                     compute_type=self.compute_type,\n                                     download_root=self.download_root,\n                                     language=self.language)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'm-bain/whisperX'\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_type\": {\n        \"type\": list,\n        \"description\": \"One of the official model names listed by `whisper.available_models()`, or path to a model checkpoint containing the model dimensions and the model state_dict.\",\n        \"options\": available_models(),\n        \"default\": \"base\",\n    },\n    \"device\": {\n        \"type\": list,\n        \"description\": 'Device to use for computation (\"cpu\", \"cuda\")',\n        \"options\": [\"cpu\", \"cuda\"],\n        \"default\": \"cpu\",\n    },\n    \"compute_type\": {\n        \"type\": list,\n        \"description\": \"change to 'int8' if low on GPU mem (may reduce accuracy)\",\n        \"options\": [\"default\", \"float16\", \"int8\"],\n        \"default\": \"default\",\n    },\n    \"download_root\": {\n        \"type\": str,\n        \"description\": \"Path to download the model files; by default, it uses '~/.cache/whisper'\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": \"language that the audio is in; uses detected language if None\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"segment_type\": {\n        \"type\": list,\n        \"description\": \"Word-level timestamps, Choose here between sentence-level and word-level\",\n        \"options\": [\"sentence\", \"word\"],\n        \"default\": \"sentence\",\n    },\n    \"batch_size\": {\n        \"type\": int,\n        \"description\": \"reduce if low on GPU mem\",\n        \"options\": None,\n        \"default\": 16,\n    },\n    \"return_char_alignments\": {\n        \"type\": bool,\n        \"description\": \"Whether to return char alignments\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"speaker_labels\": {\n        \"type\": bool,\n        \"description\": \"Run Diarization Pipeline\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"HF_TOKEN\": {\n        \"type\": str,\n        \"description\": \"if speaker labels is True, you will need Hugging Face access token to use the diarization models, https://github.com/m-bain/whisperX#speaker-diarization\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"min_speakers\": {\n        \"type\": int,\n        \"description\": \"min speakers\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"max_speakers\": {\n        \"type\": int,\n        \"description\": \"max speakers\",\n        \"options\": None,\n        \"default\": None,\n    },\n}\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.model_type","title":"model_type  <code>instance-attribute</code>","text":"<pre><code>model_type = _load_config(\n    \"model_type\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.device","title":"device  <code>instance-attribute</code>","text":"<pre><code>device = _load_config(\"device\", model_config, config_schema)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.compute_type","title":"compute_type  <code>instance-attribute</code>","text":"<pre><code>compute_type = _load_config(\n    \"compute_type\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.download_root","title":"download_root  <code>instance-attribute</code>","text":"<pre><code>download_root = _load_config(\n    \"download_root\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.language","title":"language  <code>instance-attribute</code>","text":"<pre><code>language = _load_config(\n    \"language\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.segment_type","title":"segment_type  <code>instance-attribute</code>","text":"<pre><code>segment_type = _load_config(\n    \"segment_type\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.batch_size","title":"batch_size  <code>instance-attribute</code>","text":"<pre><code>batch_size = _load_config(\n    \"batch_size\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.return_char_alignments","title":"return_char_alignments  <code>instance-attribute</code>","text":"<pre><code>return_char_alignments = _load_config(\n    \"return_char_alignments\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.speaker_labels","title":"speaker_labels  <code>instance-attribute</code>","text":"<pre><code>speaker_labels = _load_config(\n    \"speaker_labels\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.HF_TOKEN","title":"HF_TOKEN  <code>instance-attribute</code>","text":"<pre><code>HF_TOKEN = _load_config(\n    \"HF_TOKEN\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.min_speakers","title":"min_speakers  <code>instance-attribute</code>","text":"<pre><code>min_speakers = _load_config(\n    \"min_speakers\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.max_speakers","title":"max_speakers  <code>instance-attribute</code>","text":"<pre><code>max_speakers = _load_config(\n    \"max_speakers\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = load_model(\n    model_type,\n    device=device,\n    compute_type=compute_type,\n    download_root=download_root,\n    language=language,\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/whisperX_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; str:\n    audio = whisperx.load_audio(media_file)\n    result = self.model.transcribe(audio, batch_size=self.batch_size)\n    model_a, metadata = whisperx.load_align_model(language_code=result[\"language\"], device=self.device)\n    result = whisperx.align(result[\"segments\"], model_a, metadata, audio, self.device,\n                            return_char_alignments=self.return_char_alignments)\n    self._clear_gpu()\n    del model_a\n    if self.speaker_labels:\n        diarize_model = whisperx.DiarizationPipeline(use_auth_token=self.HF_TOKEN, device=self.device)\n        diarize_segments = diarize_model(audio, min_speakers=self.min_speakers, max_speakers=self.max_speakers)\n        result = whisperx.assign_word_speakers(diarize_segments, result)\n        self._clear_gpu()\n        del diarize_model\n\n    subs = SSAFile()\n\n    if self.segment_type == 'word':  # word level timestamps\n        for segment in result['segments']:\n            for word in segment['words']:\n                try:\n                    event = SSAEvent(start=pysubs2.make_time(s=word[\"start\"]), end=pysubs2.make_time(s=word[\"end\"]),\n                                     name=segment[\"speaker\"] if self.speaker_labels else \"\")\n                    event.plaintext = segment[\"speaker\"] + \": \" + word[\"word\"].strip() if self.speaker_labels else word[\"word\"].strip()\n                    subs.append(event)\n                except Exception as e:\n                    logging.warning(f\"Something wrong with {word}\")\n                    logging.warning(e)\n\n    elif self.segment_type == 'sentence':\n        for segment in result['segments']:\n            event = SSAEvent(start=pysubs2.make_time(s=segment[\"start\"]), end=pysubs2.make_time(s=segment[\"end\"]),\n                             name=segment[\"speaker\"] if self.speaker_labels else \"\")\n            event.plaintext = segment[\"speaker\"] + \": \"+ segment[\"text\"].strip() if self.speaker_labels else segment[\"text\"].strip()\n            subs.append(event)\n    else:\n        raise Exception(f'Unknown `segment_type` value, it should be one of the following: '\n                        f' {self.config_schema[\"segment_type\"][\"options\"]}')\n    return subs\n</code></pre>"},{"location":"#subsai.models.whisper_api_model","title":"whisper_api_model","text":"<p>Whisper API Model</p> <p>See openai/whisper</p>"},{"location":"#subsai.models.whisper_api_model.TMPDIR","title":"TMPDIR  <code>module-attribute</code>","text":"<pre><code>TMPDIR = gettempdir()\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.OPENAI_API_SIZE_LIMIT_MB","title":"OPENAI_API_SIZE_LIMIT_MB  <code>module-attribute</code>","text":"<pre><code>OPENAI_API_SIZE_LIMIT_MB = 24\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.WhisperAPIModel","title":"WhisperAPIModel","text":"<pre><code>WhisperAPIModel(model_config)\n</code></pre> <p>               Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/whisper_api_model.py</code> <pre><code>def __init__(self, model_config):\n    # config\n    self.model_type = _load_config('model_type', model_config, self.config_schema)\n    self.api_key = _load_config('api_key', model_config, self.config_schema)\n    self.language = _load_config('language', model_config, self.config_schema)\n    self.prompt = _load_config('prompt', model_config, self.config_schema)\n    self.temperature = _load_config('temperature', model_config, self.config_schema)\n\n    self.client = OpenAI(api_key=self.api_key)\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.WhisperAPIModel.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'openai/whisper'\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.WhisperAPIModel.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_type\": {\n        \"type\": list,\n        \"description\": \"OpenAI Whisper API, currently only supports large-v2 which is named as whisper-1/                                 There is a 25mb upload limit so audio is chunked locally, this may lead to lower performance.\",\n        \"options\": [\"whisper-1\"],\n        \"default\": \"whisper-1\",\n    },\n    \"api_key\": {\n        \"type\": str,\n        \"description\": \"Your OpenAI API key\",\n        \"options\": None,\n        \"default\": get(\"OPENAI_KEY\", None),\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": \"The language of the input audio. Supplying the input language in ISO-639-1 format will improve accuracy and latency.\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"prompt\": {\n        \"type\": str,\n        \"description\": \"An optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language.\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"temperature\": {\n        \"type\": float,\n        \"description\": \"The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.\",\n        \"options\": None,\n        \"default\": 0,\n    },\n}\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.WhisperAPIModel.model_type","title":"model_type  <code>instance-attribute</code>","text":"<pre><code>model_type = _load_config(\n    \"model_type\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.WhisperAPIModel.api_key","title":"api_key  <code>instance-attribute</code>","text":"<pre><code>api_key = _load_config(\n    \"api_key\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.WhisperAPIModel.language","title":"language  <code>instance-attribute</code>","text":"<pre><code>language = _load_config(\n    \"language\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.WhisperAPIModel.prompt","title":"prompt  <code>instance-attribute</code>","text":"<pre><code>prompt = _load_config(\"prompt\", model_config, config_schema)\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.WhisperAPIModel.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature = _load_config(\n    \"temperature\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.WhisperAPIModel.client","title":"client  <code>instance-attribute</code>","text":"<pre><code>client = OpenAI(api_key=api_key)\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.WhisperAPIModel.chunk_audio","title":"chunk_audio","text":"<pre><code>chunk_audio(audio_file_path)\n</code></pre> Source code in <code>src/subsai/models/whisper_api_model.py</code> <pre><code>def chunk_audio(self,audio_file_path) -&gt; list:\n    # Load the audio file\n    audio = AudioSegment.from_mp3(audio_file_path)\n\n    # Desired chunk size in megabytes (MB)\n    chunk_size_bits = OPENAI_API_SIZE_LIMIT_MB * 1024 * 1024 * 8\n    bitrate = audio.frame_rate * audio.frame_width\n    chunk_duration_ms = ((chunk_size_bits) / bitrate) * 1000\n\n    chunks = []\n\n    # Split the audio into chunks\n    current_ms = 0\n    while current_ms &lt; len(audio):\n        # Calculate the end of the current chunk\n        end_ms = current_ms + chunk_duration_ms\n        # Create a chunk from the current position to the end position\n        chunk = audio[current_ms:int(end_ms)]\n        # Add the chunk to the list of chunks and include offset\n        chunks.append((chunk,current_ms))\n        # Update the current position\n        current_ms = end_ms\n\n    return chunks\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.WhisperAPIModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/whisper_api_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; str:\n\n    audio_file_path = convert_video_to_audio_ffmpeg(media_file)\n\n    chunks = self.chunk_audio(audio_file_path)\n\n    results = ''\n\n    for i, (chunk,offset) in enumerate(chunks):\n        chunk_path = os.path.join(TMPDIR,f'chunk_{i}.mp3')\n        print('Transcribing audio chunk {}/{}'.format(i,len(chunks)))\n        chunk.export(chunk_path, format='mp3')\n        audio_file = open(chunk_path, \"rb\")\n\n        # Use OpenAI Whisper API\n        result = self.client.audio.transcriptions.create(\n            model=self.model_type,\n            language=self.language,\n            prompt=self.prompt,\n            temperature=self.temperature,\n            file=audio_file,\n            response_format=\"srt\"\n        )\n\n        with open(chunk_path+'.srt','w') as f:\n            f.write(result)\n\n        # shift subtitles by offset\n        result = SSAFile.from_string(result)\n        result.shift(ms=offset)\n        results += result.to_string('srt')\n\n    results = ''.join(results)\n\n    return SSAFile.from_string(results)\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.split_filename","title":"split_filename","text":"<pre><code>split_filename(filepath)\n</code></pre> Source code in <code>src/subsai/models/whisper_api_model.py</code> <pre><code>def split_filename(filepath):\n    path, full_filename = os.path.split(filepath)\n    filename, ext = os.path.splitext(full_filename)\n    return path,filename,ext\n</code></pre>"},{"location":"#subsai.models.whisper_api_model.convert_video_to_audio_ffmpeg","title":"convert_video_to_audio_ffmpeg","text":"<pre><code>convert_video_to_audio_ffmpeg(video_file, output_ext='mp3')\n</code></pre> Source code in <code>src/subsai/models/whisper_api_model.py</code> <pre><code>def convert_video_to_audio_ffmpeg(video_file, output_ext=\"mp3\"):\n    # Construct the output file name\n    path,filename,ext = split_filename(video_file)\n    output_file = os.path.join(TMPDIR,f\"{filename}.{output_ext}\")\n\n\n    print('Saving audio to {} with ffmpeg...'.format(output_file))\n    # Execute the ffmpeg conversion\n    (\n        ffmpeg\n        .input(video_file)\n        .output(output_file)\n        .overwrite_output()\n        .run(quiet=True)\n    )\n    return output_file\n</code></pre>"},{"location":"#subsai.models.whisper_model","title":"whisper_model","text":"<p>Whisper Model</p> <p>See openai/whisper</p>"},{"location":"#subsai.models.whisper_model.WhisperModel","title":"WhisperModel","text":"<pre><code>WhisperModel(model_config)\n</code></pre> <p>               Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/whisper_model.py</code> <pre><code>def __init__(self, model_config):\n    super(WhisperModel, self).__init__(model_config=model_config,\n                                       model_name=self.model_name)\n    # config\n    self.model_type = _load_config('model_type', model_config, self.config_schema)\n    self.device = _load_config('device', model_config, self.config_schema)\n    self.download_root = _load_config('download_root', model_config, self.config_schema)\n    self.in_memory = _load_config('in_memory', model_config, self.config_schema)\n\n    self.verbose = _load_config('verbose', model_config, self.config_schema)\n    self.temperature = _load_config('temperature', model_config, self.config_schema)\n    self.compression_ratio_threshold = _load_config('compression_ratio_threshold', model_config, self.config_schema)\n    self.logprob_threshold = _load_config('logprob_threshold', model_config, self.config_schema)\n    self.no_speech_threshold = _load_config('no_speech_threshold', model_config, self.config_schema)\n    self.condition_on_previous_text = _load_config('condition_on_previous_text', model_config, self.config_schema)\n\n    self.decode_options = \\\n        {config: _load_config(config, model_config, self.config_schema)\n         for config in self.config_schema if not hasattr(self, config)}\n\n    self.model = whisper.load_model(name=self.model_type,\n                                    device=self.device,\n                                    download_root=self.download_root,\n                                    in_memory=self.in_memory)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'openai/whisper'\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_type\": {\n        \"type\": list,\n        \"description\": \"One of the official model names listed by `whisper.available_models()`, or path to a model checkpoint containing the model dimensions and the model state_dict.\",\n        \"options\": available_models(),\n        \"default\": \"base\",\n    },\n    \"device\": {\n        \"type\": list,\n        \"description\": \"The PyTorch device to put the model into\",\n        \"options\": [None, *get_available_devices()],\n        \"default\": None,\n    },\n    \"download_root\": {\n        \"type\": str,\n        \"description\": \"Path to download the model files; by default, it uses '~/.cache/whisper'\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"in_memory\": {\n        \"type\": bool,\n        \"description\": \"whether to preload the model weights into host memory\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"verbose\": {\n        \"type\": bool,\n        \"description\": \"Whether to display the text being decoded to the console. If True, displays all the details,If False, displays minimal details. If None, does not display anything\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"temperature\": {\n        \"type\": Tuple,\n        \"description\": \"Temperature for sampling. It can be a tuple of temperatures, which will be successively used upon failures according to either `compression_ratio_threshold` or `logprob_threshold`.\",\n        \"options\": None,\n        \"default\": (0.0, 0.2, 0.4, 0.6, 0.8, 1.0),\n    },\n    \"compression_ratio_threshold\": {\n        \"type\": float,\n        \"description\": \"If the gzip compression ratio is above this value, treat as failed\",\n        \"options\": None,\n        \"default\": 2.4,\n    },\n    \"logprob_threshold\": {\n        \"type\": float,\n        \"description\": \"If the average log probability over sampled tokens is below this value, treat as failed\",\n        \"options\": None,\n        \"default\": -1.0,\n    },\n    \"no_speech_threshold\": {\n        \"type\": float,\n        \"description\": \"If the no_speech probability is higher than this value AND the average log probability over sampled tokens is below `logprob_threshold`, consider the segment as silent\",\n        \"options\": None,\n        \"default\": 0.6,\n    },\n    \"condition_on_previous_text\": {\n        \"type\": bool,\n        \"description\": \"if True, the previous output of the model is provided as a prompt for the next window; disabling may make the text inconsistent across windows, but the model becomes less prone to getting stuck in a failure loop, such as repetition looping or timestamps going out of sync.\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"task\": {\n        \"type\": list,\n        \"description\": \"whether to perform X-&gt;X 'transcribe' or X-&gt;English 'translate'\",\n        \"options\": [\"transcribe\", \"translate\"],\n        \"default\": \"transcribe\",\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": \"language that the audio is in; uses detected language if None\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"sample_len\": {\n        \"type\": int,\n        \"description\": \"maximum number of tokens to sample\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"best_of\": {\n        \"type\": int,\n        \"description\": \"number of independent samples to collect, when t &gt; 0\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"beam_size\": {\n        \"type\": int,\n        \"description\": \"number of beams in beam search, when t == 0\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"patience\": {\n        \"type\": float,\n        \"description\": \"patience in beam search (https://arxiv.org/abs/2204.05424)\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"length_penalty\": {\n        \"type\": float,\n        \"description\": \"'alpha' in Google NMT, None defaults to length norm\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"prompt\": {\n        \"type\": str,\n        \"description\": \"text or tokens for the previous context\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"prefix\": {\n        \"type\": str,\n        \"description\": \"text or tokens to prefix the current context\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"suppress_blank\": {\n        \"type\": bool,\n        \"description\": \"this will suppress blank outputs\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"suppress_tokens\": {\n        \"type\": str,\n        \"description\": 'list of tokens ids (or comma-separated token ids) to suppress \"-1\" will suppress a set of symbols as defined in `tokenizer.non_speech_tokens()`',\n        \"options\": None,\n        \"default\": \"-1\",\n    },\n    \"without_timestamps\": {\n        \"type\": bool,\n        \"description\": \"use &lt;|notimestamps|&gt; to sample text tokens only\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"max_initial_timestamp\": {\n        \"type\": float,\n        \"description\": \"the initial timestamp cannot be later than this\",\n        \"options\": None,\n        \"default\": 1.0,\n    },\n    \"fp16\": {\n        \"type\": bool,\n        \"description\": \"use fp16 for most of the calculation\",\n        \"options\": None,\n        \"default\": True,\n    },\n}\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.model_type","title":"model_type  <code>instance-attribute</code>","text":"<pre><code>model_type = _load_config(\n    \"model_type\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.device","title":"device  <code>instance-attribute</code>","text":"<pre><code>device = _load_config(\"device\", model_config, config_schema)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.download_root","title":"download_root  <code>instance-attribute</code>","text":"<pre><code>download_root = _load_config(\n    \"download_root\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.in_memory","title":"in_memory  <code>instance-attribute</code>","text":"<pre><code>in_memory = _load_config(\n    \"in_memory\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.verbose","title":"verbose  <code>instance-attribute</code>","text":"<pre><code>verbose = _load_config(\n    \"verbose\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature = _load_config(\n    \"temperature\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.compression_ratio_threshold","title":"compression_ratio_threshold  <code>instance-attribute</code>","text":"<pre><code>compression_ratio_threshold = _load_config(\n    \"compression_ratio_threshold\",\n    model_config,\n    config_schema,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.logprob_threshold","title":"logprob_threshold  <code>instance-attribute</code>","text":"<pre><code>logprob_threshold = _load_config(\n    \"logprob_threshold\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.no_speech_threshold","title":"no_speech_threshold  <code>instance-attribute</code>","text":"<pre><code>no_speech_threshold = _load_config(\n    \"no_speech_threshold\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.condition_on_previous_text","title":"condition_on_previous_text  <code>instance-attribute</code>","text":"<pre><code>condition_on_previous_text = _load_config(\n    \"condition_on_previous_text\",\n    model_config,\n    config_schema,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.decode_options","title":"decode_options  <code>instance-attribute</code>","text":"<pre><code>decode_options = {\n    config: _load_config(\n        config, model_config, config_schema\n    )\n    for config in config_schema\n    if not hasattr(self, config)\n}\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = load_model(\n    name=model_type,\n    device=device,\n    download_root=download_root,\n    in_memory=in_memory,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/whisper_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; str:\n    audio = whisper.load_audio(media_file)\n    result = self.model.transcribe(audio,\n                                   verbose=self.verbose,\n                                   temperature=self.temperature,\n                                   compression_ratio_threshold=self.compression_ratio_threshold,\n                                   logprob_threshold=self.logprob_threshold,\n                                   no_speech_threshold=self.no_speech_threshold,\n                                   condition_on_previous_text=self.condition_on_previous_text,\n                                   **self.decode_options)\n    subs = pysubs2.load_from_whisper(result)\n    return subs\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model","title":"whisper_timestamped_model","text":"<p>whisper_timestamped</p> <p>See linto-ai/whisper-timestamped</p>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped","title":"WhisperTimeStamped","text":"<pre><code>WhisperTimeStamped(model_config={})\n</code></pre> <p>               Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/whisper_timestamped_model.py</code> <pre><code>def __init__(self, model_config={}):\n    super(WhisperTimeStamped, self).__init__(model_config=model_config,\n                                             model_name=self.model_name)\n    # config\n    self.model_type = _load_config('model_type', model_config, self.config_schema)\n    self.segment_type = _load_config('segment_type', model_config, self.config_schema)\n    self.device = _load_config('device', model_config, self.config_schema)\n    self.download_root = _load_config('download_root', model_config, self.config_schema)\n    self.in_memory = _load_config('in_memory', model_config, self.config_schema)\n\n    self.verbose = _load_config('verbose', model_config, self.config_schema)\n    self.temperature = _load_config('temperature', model_config, self.config_schema)\n    self.compression_ratio_threshold = _load_config('compression_ratio_threshold', model_config, self.config_schema)\n    self.logprob_threshold = _load_config('logprob_threshold', model_config, self.config_schema)\n    self.no_speech_threshold = _load_config('no_speech_threshold', model_config, self.config_schema)\n    self.condition_on_previous_text = _load_config('condition_on_previous_text', model_config, self.config_schema)\n\n    self.decode_options = \\\n        {config: _load_config(config, model_config, self.config_schema)\n         for config in self.config_schema if not hasattr(self, config)}\n\n    self.model = whisper_timestamped.load_model(name=self.model_type,\n                                                device=self.device,\n                                                download_root=self.download_root,\n                                                in_memory=self.in_memory)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'linto-ai/whisper-timestamped'\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_type\": {\n        \"type\": list,\n        \"description\": \"One of the official model names listed by `whisper.available_models()`, or path to a model checkpoint containing the model dimensions and the model state_dict.\",\n        \"options\": available_models(),\n        \"default\": \"base\",\n    },\n    \"segment_type\": {\n        \"type\": list,\n        \"description\": \"Whisper_timestamps gives the ability to have word-level timestamps, Choose here between sentence-level and word-level\",\n        \"options\": [\"sentence\", \"word\"],\n        \"default\": \"sentence\",\n    },\n    \"device\": {\n        \"type\": list,\n        \"description\": \"The PyTorch device to put the model into\",\n        \"options\": [None, *get_available_devices()],\n        \"default\": None,\n    },\n    \"download_root\": {\n        \"type\": str,\n        \"description\": \"Path to download the model files; by default, it uses '~/.cache/whisper'\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"in_memory\": {\n        \"type\": bool,\n        \"description\": \"whether to preload the model weights into host memory\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"verbose\": {\n        \"type\": bool,\n        \"description\": \"Whether to display the text being decoded to the console. If True, displays all the details,If False, displays minimal details. If None, does not display anything\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"temperature\": {\n        \"type\": Tuple,\n        \"description\": \"Temperature for sampling. It can be a tuple of temperatures, which will be successively used upon failures according to either `compression_ratio_threshold` or `logprob_threshold`.\",\n        \"options\": None,\n        \"default\": (0.0, 0.2, 0.4, 0.6, 0.8, 1.0),\n    },\n    \"compression_ratio_threshold\": {\n        \"type\": float,\n        \"description\": \"If the gzip compression ratio is above this value, treat as failed\",\n        \"options\": None,\n        \"default\": 2.4,\n    },\n    \"logprob_threshold\": {\n        \"type\": float,\n        \"description\": \"If the average log probability over sampled tokens is below this value, treat as failed\",\n        \"options\": None,\n        \"default\": -1.0,\n    },\n    \"no_speech_threshold\": {\n        \"type\": float,\n        \"description\": \"If the no_speech probability is higher than this value AND the average log probability over sampled tokens is below `logprob_threshold`, consider the segment as silent\",\n        \"options\": None,\n        \"default\": 0.6,\n    },\n    \"condition_on_previous_text\": {\n        \"type\": bool,\n        \"description\": \"if True, the previous output of the model is provided as a prompt for the next window; disabling may make the text inconsistent across windows, but the model becomes less prone to getting stuck in a failure loop, such as repetition looping or timestamps going out of sync.\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"task\": {\n        \"type\": list,\n        \"description\": \"whether to perform X-&gt;X 'transcribe' or X-&gt;English 'translate'\",\n        \"options\": [\"transcribe\", \"translate\"],\n        \"default\": \"transcribe\",\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": \"language that the audio is in; uses detected language if None\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"sample_len\": {\n        \"type\": int,\n        \"description\": \"maximum number of tokens to sample\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"best_of\": {\n        \"type\": int,\n        \"description\": \"number of independent samples to collect, when t &gt; 0\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"beam_size\": {\n        \"type\": int,\n        \"description\": \"number of beams in beam search, when t == 0\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"patience\": {\n        \"type\": float,\n        \"description\": \"patience in beam search (https://arxiv.org/abs/2204.05424)\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"length_penalty\": {\n        \"type\": float,\n        \"description\": \"'alpha' in Google NMT, None defaults to length norm\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"suppress_tokens\": {\n        \"type\": str,\n        \"description\": 'list of tokens ids (or comma-separated token ids) to suppress \"-1\" will suppress a set of symbols as defined in `tokenizer.non_speech_tokens()`',\n        \"options\": None,\n        \"default\": \"-1\",\n    },\n    \"fp16\": {\n        \"type\": bool,\n        \"description\": \"use fp16 for most of the calculation\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"remove_punctuation_from_words\": {\n        \"type\": bool,\n        \"description\": \"If False, words will be glued with the next punctuation mark (if any).If True, there will be no punctuation mark in the `words[:]['text']` list.It only affects these strings; This has no influence on the computation of the word confidence, whatever the value of `include_punctuation_in_confidence` is.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"refine_whisper_precision\": {\n        \"type\": float,\n        \"description\": \"How much can we refine Whisper segment positions, in seconds. Must be a multiple of 0.02.\",\n        \"options\": None,\n        \"default\": 0.5,\n    },\n    \"min_word_duration\": {\n        \"type\": float,\n        \"description\": \"Minimum duration of a word, in seconds. If a word is shorter than this, timestamps will be adjusted.\",\n        \"options\": None,\n        \"default\": 0.04,\n    },\n    \"plot_word_alignment\": {\n        \"type\": bool,\n        \"description\": \"Whether to plot the word alignment for each segment. matplotlib must be installed to use this option.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"seed\": {\n        \"type\": int,\n        \"description\": \"Random seed to use for temperature sampling, for the sake of reproducibility.Choose None for unpredictable randomness\",\n        \"options\": None,\n        \"default\": 1234,\n    },\n    \"vad\": {\n        \"type\": bool,\n        \"description\": \"Whether to perform voice activity detection (VAD) on the audio file, to remove silent parts before transcribing with Whisper model. This should decrease hallucinations from the Whisper model.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"detect_disfluencies\": {\n        \"type\": bool,\n        \"description\": 'Whether to detect disfluencies (i.e. hesitations, filler words, repetitions, corrections, etc.) that Whisper model might have omitted in the transcription. This should make the word timestamp prediction more accurate.And probable disfluencies will be marked as special words \"[*]\"',\n        \"options\": None,\n        \"default\": False,\n    },\n    \"trust_whisper_timestamps\": {\n        \"type\": bool,\n        \"description\": \"Whether to rely on Whisper's timestamps to get approximative first estimate of segment positions (up to refine_whisper_precision).\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"naive_approach\": {\n        \"type\": bool,\n        \"description\": \"Force the naive approach that consists in decoding twice the audio file, once to get the transcription and once with the decoded tokens to get the alignment. Note that this approach is used anyway when beam_size is not None and/or when the temperature is a list with more than one element.\",\n        \"options\": None,\n        \"default\": False,\n    },\n}\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.model_type","title":"model_type  <code>instance-attribute</code>","text":"<pre><code>model_type = _load_config(\n    \"model_type\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.segment_type","title":"segment_type  <code>instance-attribute</code>","text":"<pre><code>segment_type = _load_config(\n    \"segment_type\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.device","title":"device  <code>instance-attribute</code>","text":"<pre><code>device = _load_config(\"device\", model_config, config_schema)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.download_root","title":"download_root  <code>instance-attribute</code>","text":"<pre><code>download_root = _load_config(\n    \"download_root\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.in_memory","title":"in_memory  <code>instance-attribute</code>","text":"<pre><code>in_memory = _load_config(\n    \"in_memory\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.verbose","title":"verbose  <code>instance-attribute</code>","text":"<pre><code>verbose = _load_config(\n    \"verbose\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature = _load_config(\n    \"temperature\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.compression_ratio_threshold","title":"compression_ratio_threshold  <code>instance-attribute</code>","text":"<pre><code>compression_ratio_threshold = _load_config(\n    \"compression_ratio_threshold\",\n    model_config,\n    config_schema,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.logprob_threshold","title":"logprob_threshold  <code>instance-attribute</code>","text":"<pre><code>logprob_threshold = _load_config(\n    \"logprob_threshold\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.no_speech_threshold","title":"no_speech_threshold  <code>instance-attribute</code>","text":"<pre><code>no_speech_threshold = _load_config(\n    \"no_speech_threshold\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.condition_on_previous_text","title":"condition_on_previous_text  <code>instance-attribute</code>","text":"<pre><code>condition_on_previous_text = _load_config(\n    \"condition_on_previous_text\",\n    model_config,\n    config_schema,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.decode_options","title":"decode_options  <code>instance-attribute</code>","text":"<pre><code>decode_options = {\n    config: _load_config(\n        config, model_config, config_schema\n    )\n    for config in config_schema\n    if not hasattr(self, config)\n}\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = load_model(\n    name=model_type,\n    device=device,\n    download_root=download_root,\n    in_memory=in_memory,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/whisper_timestamped_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; str:\n    audio = whisper_timestamped.load_audio(media_file)\n    results = whisper_timestamped.transcribe(self.model, audio,\n                                             verbose=self.verbose,\n                                             temperature=self.temperature,\n                                             compression_ratio_threshold=self.compression_ratio_threshold,\n                                             logprob_threshold=self.logprob_threshold,\n                                             no_speech_threshold=self.no_speech_threshold,\n                                             condition_on_previous_text=self.condition_on_previous_text,\n                                             **self.decode_options\n                                             )\n    subs = SSAFile()\n    if self.segment_type == 'word':  # word level timestamps\n        for segment in results['segments']:\n            for word in segment['words']:\n                event = SSAEvent(start=pysubs2.make_time(s=word[\"start\"]), end=pysubs2.make_time(s=word[\"end\"]))\n                event.plaintext = word[\"text\"].strip()\n                subs.append(event)\n    elif self.segment_type == 'sentence':\n        for segment in results['segments']:\n            event = SSAEvent(start=pysubs2.make_time(s=segment[\"start\"]), end=pysubs2.make_time(s=segment[\"end\"]))\n            event.plaintext = segment[\"text\"].strip()\n            subs.append(event)\n    else:\n        raise Exception(f'Unknown `segment_type` value, it should be one of the following: '\n                        f' {self.config_schema[\"segment_type\"][\"options\"]}')\n    return subs\n</code></pre>"},{"location":"#subsai.models.whispercpp_model","title":"whispercpp_model","text":"<p>Whisper.cpp Model</p> <p>See whisper.cpp, See pywhispercpp</p>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel","title":"WhisperCppModel","text":"<pre><code>WhisperCppModel(model_config)\n</code></pre> <p>               Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/whispercpp_model.py</code> <pre><code>def __init__(self, model_config):\n    super(WhisperCppModel, self).__init__(model_config=model_config,\n                                       model_name=self.model_name)\n    # config\n    self.model_type = _load_config('model_type', model_config, self.config_schema)\n\n    self.params = {}\n    for config in self.config_schema:\n        if not hasattr(self, config):\n            config_value = _load_config(config, model_config, self.config_schema)\n            if config_value is None:\n                continue\n            self.params[config] = config_value\n\n    self.model = Model(model=self.model_type, **self.params)\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'ggerganov/whisper.cpp'\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_type\": {\n        \"type\": list,\n        \"description\": \"Available whisper.cpp models\",\n        \"options\": AVAILABLE_MODELS,\n        \"default\": \"base\",\n    },\n    \"n_threads\": {\n        \"type\": int,\n        \"description\": \"Number of threads to allocate for the inferencedefault to min(4, available hardware_concurrency)\",\n        \"options\": None,\n        \"default\": 4,\n    },\n    \"n_max_text_ctx\": {\n        \"type\": int,\n        \"description\": \"max tokens to use from past text as prompt for the decoder\",\n        \"options\": None,\n        \"default\": 16384,\n    },\n    \"offset_ms\": {\n        \"type\": int,\n        \"description\": \"start offset in ms\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"duration_ms\": {\n        \"type\": int,\n        \"description\": \"audio duration to process in ms\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"translate\": {\n        \"type\": bool,\n        \"description\": \"whether to translate the audio to English\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"no_context\": {\n        \"type\": bool,\n        \"description\": \"do not use past transcription (if any) as initial prompt for the decoder\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"single_segment\": {\n        \"type\": bool,\n        \"description\": \"force single segment output (useful for streaming)\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"print_special\": {\n        \"type\": bool,\n        \"description\": \"print special tokens (e.g. &lt;SOT&gt;, &lt;EOT&gt;, &lt;BEG&gt;, etc.)\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"print_progress\": {\n        \"type\": bool,\n        \"description\": \"print progress information\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"print_realtime\": {\n        \"type\": bool,\n        \"description\": \"print results from within whisper.cpp (avoid it, use callback instead)\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"print_timestamps\": {\n        \"type\": bool,\n        \"description\": \"print timestamps for each text segment when printing realtime\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"token_timestamps\": {\n        \"type\": bool,\n        \"description\": \"enable token-level timestamps\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"thold_pt\": {\n        \"type\": float,\n        \"description\": \"timestamp token probability threshold (~0.01)\",\n        \"options\": None,\n        \"default\": 0.01,\n    },\n    \"thold_ptsum\": {\n        \"type\": float,\n        \"description\": \"timestamp token sum probability threshold (~0.01)\",\n        \"options\": None,\n        \"default\": 0.01,\n    },\n    \"max_len\": {\n        \"type\": int,\n        \"description\": \"max segment length in characters\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"split_on_word\": {\n        \"type\": bool,\n        \"description\": \"split on word rather than on token (when used with max_len)\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"max_tokens\": {\n        \"type\": int,\n        \"description\": \"max tokens per segment (0 = no limit)\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"speed_up\": {\n        \"type\": bool,\n        \"description\": \"speed-up the audio by 2x using Phase Vocoder\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"audio_ctx\": {\n        \"type\": int,\n        \"description\": \"overwrite the audio context size (0 = use default)\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"prompt_n_tokens\": {\n        \"type\": int,\n        \"description\": \"tokens to provide to the whisper decoder as initial prompt\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": 'for auto-detection, set to None, \"\" or \"auto\"',\n        \"options\": None,\n        \"default\": \"en\",\n    },\n    \"suppress_blank\": {\n        \"type\": bool,\n        \"description\": \"common decoding parameters\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"suppress_non_speech_tokens\": {\n        \"type\": bool,\n        \"description\": \"common decoding parameters\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"temperature\": {\n        \"type\": float,\n        \"description\": \"initial decoding temperature\",\n        \"options\": None,\n        \"default\": 0.0,\n    },\n    \"max_initial_ts\": {\n        \"type\": float,\n        \"description\": \"max_initial_ts\",\n        \"options\": None,\n        \"default\": 1.0,\n    },\n    \"length_penalty\": {\n        \"type\": float,\n        \"description\": \"length_penalty\",\n        \"options\": None,\n        \"default\": -1.0,\n    },\n    \"temperature_inc\": {\n        \"type\": float,\n        \"description\": \"temperature_inc\",\n        \"options\": None,\n        \"default\": 0.2,\n    },\n    \"entropy_thold\": {\n        \"type\": float,\n        \"description\": 'similar to OpenAI\\'s \"compression_ratio_threshold\"',\n        \"options\": None,\n        \"default\": 2.4,\n    },\n    \"logprob_thold\": {\n        \"type\": float,\n        \"description\": \"logprob_thold\",\n        \"options\": None,\n        \"default\": -1.0,\n    },\n    \"no_speech_thold\": {\n        \"type\": float,\n        \"description\": \"no_speech_thold\",\n        \"options\": None,\n        \"default\": 0.6,\n    },\n    \"greedy\": {\n        \"type\": dict,\n        \"description\": \"greedy\",\n        \"options\": None,\n        \"default\": {\"best_of\": -1},\n    },\n    \"beam_search\": {\n        \"type\": dict,\n        \"description\": \"beam_search\",\n        \"options\": None,\n        \"default\": {\"beam_size\": -1, \"patience\": -1.0},\n    },\n}\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.model_type","title":"model_type  <code>instance-attribute</code>","text":"<pre><code>model_type = _load_config(\n    \"model_type\", model_config, config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params = {}\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = Model(model=model_type, **params)\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/whispercpp_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; str:\n    segments = self.model.transcribe(media=media_file)\n    subs = SSAFile()\n    for seg in segments:\n        event = SSAEvent(start=seg.t0*10, end=seg.t1*10)\n        event.plaintext = seg.text.strip()\n        subs.append(event)\n    return subs\n</code></pre>"},{"location":"#subsai.configs","title":"subsai.configs","text":"<p>Configurations file</p>"},{"location":"#subsai.configs.AVAILABLE_MODELS","title":"AVAILABLE_MODELS  <code>module-attribute</code>","text":"<pre><code>AVAILABLE_MODELS = {\n    \"openai/whisper\": {\n        \"class\": WhisperModel,\n        \"description\": \"Whisper is a general-purpose speech recognition model. It is trained on a large dataset of diverse audio and is also a multi-task model that can perform multilingual speech recognition as well as speech translation and language identification.\",\n        \"url\": \"https://github.com/openai/whisper\",\n        \"config_schema\": config_schema,\n    },\n    \"linto-ai/whisper-timestamped\": {\n        \"class\": WhisperTimeStamped,\n        \"description\": \"Multilingual Automatic Speech Recognition with word-level timestamps and confidence.\",\n        \"url\": \"https://github.com/linto-ai/whisper-timestamped\",\n        \"config_schema\": config_schema,\n    },\n    \"ggerganov/whisper.cpp\": {\n        \"class\": WhisperCppModel,\n        \"description\": \"High-performance inference of OpenAI's Whisper automatic speech recognition (ASR) model\\n* Plain C/C++ implementation without dependencies\\n* Runs on the CPU\\n\",\n        \"url\": \"https://github.com/ggerganov/whisper.cpp\\nhttps://github.com/abdeladim-s/pywhispercpp\",\n        \"config_schema\": config_schema,\n    },\n    \"guillaumekln/faster-whisper\": {\n        \"class\": FasterWhisperModel,\n        \"description\": \"**faster-whisper** is a reimplementation of OpenAI's Whisper model using [CTranslate2](https://github.com/OpenNMT/CTranslate2/), which is a fast inference engine for Transformer models.\\nThis implementation is up to 4 times faster than [openai/whisper]( https://github.com/openai/whisper) for the same accuracy while using less memory. The efficiency can be further improved with 8-bit quantization on both CPU and GPU.\",\n        \"url\": \"https://github.com/guillaumekln/faster-whisper\",\n        \"config_schema\": config_schema,\n    },\n    \"m-bain/whisperX\": {\n        \"class\": WhisperXModel,\n        \"description\": \"**whisperX** is a fast automatic speech recognition (70x realtime with large-v2) with word-level timestamps and speaker diarization.\",\n        \"url\": \"https://github.com/m-bain/whisperX\",\n        \"config_schema\": config_schema,\n    },\n    \"jianfch/stable-ts\": {\n        \"class\": StableTsModel,\n        \"description\": \"**Stabilizing Timestamps for Whisper** This library modifies [Whisper](https://github.com/openai/whisper) to produce more reliable timestamps and extends its functionality.\",\n        \"url\": \"https://github.com/jianfch/stable-ts\",\n        \"config_schema\": config_schema,\n    },\n    \"API/openai/whisper\": {\n        \"class\": WhisperAPIModel,\n        \"description\": \"API for the OpenAI large-v2 Whisper model, requires an API key.\",\n        \"url\": \"https://platform.openai.com/docs/guides/speech-to-text\",\n        \"config_schema\": config_schema,\n    },\n    \"HuggingFace\": {\n        \"class\": HuggingFaceModel,\n        \"description\": \"Hugging Face implementation of Whisper. Any speech recognition pretrained model from the Hugging Face hub can be used as well\",\n        \"url\": \"https://huggingface.co/tasks/automatic-speech-recognition\",\n        \"config_schema\": config_schema,\n    },\n}\n</code></pre>"},{"location":"#subsai.configs.BASIC_TOOLS_CONFIGS","title":"BASIC_TOOLS_CONFIGS  <code>module-attribute</code>","text":"<pre><code>BASIC_TOOLS_CONFIGS = {\n    \"set time\": {\n        \"description\": \"Set time to a subtitle\",\n        \"config_schema\": {\n            \"h\": {\n                \"type\": float,\n                \"description\": \"hours: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"m\": {\n                \"type\": float,\n                \"description\": \"minutes: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"s\": {\n                \"type\": float,\n                \"description\": \"seconds: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"ms\": {\n                \"type\": float,\n                \"description\": \"milliseconds: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n        },\n    },\n    \"shift\": {\n        \"description\": \"Shift all subtitles by constant time amount\",\n        \"config_schema\": {\n            \"h\": {\n                \"type\": float,\n                \"description\": \"hours: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"m\": {\n                \"type\": float,\n                \"description\": \"minutes: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"s\": {\n                \"type\": float,\n                \"description\": \"seconds: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"ms\": {\n                \"type\": float,\n                \"description\": \"milliseconds: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"frames\": {\n                \"type\": int,\n                \"description\": \"When specified, must be an integer number of frames\",\n                \"options\": None,\n                \"default\": None,\n            },\n            \"fps\": {\n                \"type\": float,\n                \"description\": \"When specified, must be a positive number.\",\n                \"options\": None,\n                \"default\": None,\n            },\n        },\n    },\n}\n</code></pre>"},{"location":"#subsai.configs.ADVANCED_TOOLS_CONFIGS","title":"ADVANCED_TOOLS_CONFIGS  <code>module-attribute</code>","text":"<pre><code>ADVANCED_TOOLS_CONFIGS = {\n    \"ffsubsync\": {\n        \"description\": \"Language-agnostic automatic synchronization of subtitles with video, so that subtitles are aligned to the correct starting point within the video.\",\n        \"url\": \"https://github.com/smacke/ffsubsync\",\n        \"config_schema\": {\n            \"vad\": {\n                \"type\": list,\n                \"description\": \"Which voice activity detector to use for speech extraction (if using video / audio as a reference\",\n                \"options\": [\n                    \"subs_then_webrtc\",\n                    \"webrtc\",\n                    \"subs_then_auditok\",\n                    \"auditok\",\n                    \"subs_then_silero\",\n                    \"silero\",\n                ],\n                \"default\": DEFAULT_VAD,\n            },\n            \"max-subtitle-seconds\": {\n                \"type\": float,\n                \"description\": \"Maximum duration for a subtitle to appear on-screen\",\n                \"options\": None,\n                \"default\": DEFAULT_MAX_SUBTITLE_SECONDS,\n            },\n            \"start-seconds\": {\n                \"type\": int,\n                \"description\": \"Start time for processing\",\n                \"options\": None,\n                \"default\": DEFAULT_START_SECONDS,\n            },\n            \"max-offset-seconds\": {\n                \"type\": float,\n                \"description\": \"The max allowed offset seconds for any subtitle segment\",\n                \"options\": None,\n                \"default\": DEFAULT_MAX_OFFSET_SECONDS,\n            },\n            \"apply-offset-seconds\": {\n                \"type\": float,\n                \"description\": \"Apply a predefined offset in seconds to all subtitle segments\",\n                \"options\": None,\n                \"default\": DEFAULT_APPLY_OFFSET_SECONDS,\n            },\n            \"suppress-output-if-offset-less-than\": {\n                \"type\": float,\n                \"description\": \"Apply a predefined offset in seconds to all subtitle segments\",\n                \"options\": None,\n                \"default\": None,\n            },\n            \"frame-rate\": {\n                \"type\": int,\n                \"description\": \"Frame rate for audio extraction\",\n                \"options\": None,\n                \"default\": DEFAULT_FRAME_RATE,\n            },\n            \"output-encoding\": {\n                \"type\": str,\n                \"description\": 'What encoding to use for writing output subtitles (default=utf-8). Can indicate \"same\" to use same encoding as that of the input.',\n                \"options\": None,\n                \"default\": \"utf-8\",\n            },\n            \"skip-infer-framerate-ratio\": {\n                \"type\": bool,\n                \"description\": \"If set, do not try to infer framerate ratio based on duration ratio.\",\n                \"options\": None,\n                \"default\": False,\n            },\n            \"no-fix-framerate\": {\n                \"type\": bool,\n                \"description\": \"If specified, subsync will not attempt to correct a framerate\",\n                \"options\": None,\n                \"default\": False,\n            },\n            \"serialize-speech\": {\n                \"type\": bool,\n                \"description\": \"If specified, serialize reference speech to a numpy array.\",\n                \"options\": None,\n                \"default\": False,\n            },\n            \"gss\": {\n                \"type\": bool,\n                \"description\": \"If specified, use golden-section search to try to findthe optimal framerate ratio between video and subtitles.\",\n                \"options\": None,\n                \"default\": False,\n            },\n        },\n    },\n    \"Translation\": {\n        \"description\": \"Translate to different languages using AI\",\n        \"url\": \"https://github.com/xhluca/dl-translate\",\n        \"config_schema\": {\n            \"model\": {\n                \"type\": list,\n                \"description\": \"The model\",\n                \"options\": available_translation_models(),\n                \"default\": available_translation_models()[\n                    0\n                ],\n            },\n            \"device\": {\n                \"type\": list,\n                \"description\": '\"cpu\", \"gpu\" or \"auto\". If it\\'s set to \"auto\", will try to select a GPU when available or else fall back to CPU',\n                \"options\": [\n                    \"auto\",\n                    *get_available_devices(),\n                ],\n                \"default\": \"auto\",\n            },\n            \"batch_size\": {\n                \"type\": int,\n                \"description\": \"The number of samples to load at once. If set to `None`, it will process everything at once\\nA smaller value is preferred for `batch_size` if your (video) RAM is limited\",\n                \"options\": None,\n                \"default\": 32,\n            },\n            \"verbose\": {\n                \"type\": bool,\n                \"description\": \"Whether to display the progress bar for every batch processed.\",\n                \"options\": None,\n                \"default\": True,\n            },\n        },\n    },\n}\n</code></pre>"}]}